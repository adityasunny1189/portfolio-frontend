import {
  concurrent_default
} from "./chunk-L6JLRZYY.js";
import {
  cascade_default
} from "./chunk-PGJPZX6B.js";
import {
  loop_default
} from "./chunk-NBUV2QNR.js";
import {
  loopOnce_default
} from "./chunk-YAUSJE2Q.js";
import {
  loopRandom_default
} from "./chunk-TJMHPMV6.js";
import "./chunk-DWHKQ65Q.js";
import "./chunk-4J54GW7H.js";
import "./chunk-TGF4NKIJ.js";
import {
  scramble_default
} from "./chunk-EKTOCOR4.js";
import "./chunk-SJDQO3DF.js";
import "./chunk-6A2TAOKG.js";
import {
  SvelteComponentDev,
  action_destroyer,
  add_location,
  append_hydration_dev,
  append_styles,
  assign,
  attr_dev,
  check_outros,
  children,
  claim_element,
  claim_space,
  create_slot,
  detach_dev,
  dispatch_dev,
  element,
  empty,
  exclude_internal_props,
  get_all_dirty_from_scope,
  get_slot_changes,
  get_spread_update,
  group_outros,
  handle_promise,
  init,
  insert_hydration_dev,
  is_function,
  noop,
  safe_not_equal,
  set_attributes,
  set_custom_element_data_map,
  space,
  toggle_class,
  transition_in,
  transition_out,
  update_await_block_branch,
  update_slot_base,
  validate_dynamic_element,
  validate_slots,
  validate_void_dynamic_element
} from "./chunk-TVA3GBF4.js";

// node_modules/svelte-typewriter/Typewriter.svelte
var file = "node_modules/svelte-typewriter/Typewriter.svelte";
function add_css(target) {
  append_styles(target, "svelte-1gv2i7t", "@keyframes svelte-1gv2i7t-cursorFade{0%,100%{opacity:1}50%{opacity:0}}.typewriter-container.svelte-1gv2i7t *:not(.typing):not(.finished-typing):not([data-static]){display:none}.typewriter-container.svelte-1gv2i7t .finished-typing::after{content:none}.cursor.svelte-1gv2i7t .typing::after{content:'';width:var(--cursor-width, 1ch);height:2ch;display:inline-block;vertical-align:text-top;background-color:var(--cursor-color, #000000);animation:svelte-1gv2i7t-cursorFade 1.25s infinite}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiVHlwZXdyaXRlci5zdmVsdGUiLCJtYXBwaW5ncyI6IkFBK0RDLFdBQVcseUJBQVcsQ0FBQSxBQUNyQixFQUFFLENBQ0YsSUFBSSxBQUFDLENBQUEsQUFDSixPQUFPLENBQUUsQ0FBQyxBQUNYLENBQUEsQUFFQSxHQUFHLEFBQUMsQ0FBQSxBQUNILE9BQU8sQ0FBRSxDQUFDLEFBQ1gsQ0FBQSxBQUNELENBQUEsQUFFQSxvQ0FBcUIsQ0FBQyxBQUFRLHVEQUF1RCxBQUFFLENBQUEsQUFDdEYsT0FBTyxDQUFFLElBQUksQUFDZCxDQUFBLEFBRUEsb0NBQXFCLENBQUMsQUFBUSx1QkFBdUIsQUFBRSxDQUFBLEFBQ3RELE9BQU8sQ0FBRSxJQUFJLEFBQ2QsQ0FBQSxBQUVHLHNCQUFPLENBQUMsQUFBUSxjQUFjLEFBQUUsQ0FBQSxBQUM1QixPQUFPLENBQUUsRUFBRSxDQUNYLEtBQUssQ0FBRSxJQUFJLGNBQWMsQ0FBQyxJQUFJLENBQUMsQ0FDL0IsTUFBTSxDQUFFLEdBQUcsQ0FDWCxPQUFPLENBQUUsWUFBWSxDQUNyQixjQUFjLENBQUUsUUFBUSxDQUN4QixnQkFBZ0IsQ0FBRSxJQUFJLGNBQWMsQ0FBQyxRQUFRLENBQUMsQ0FDOUMsU0FBUyxDQUFFLHlCQUFVLENBQUMsS0FBSyxDQUFDLFFBQVEsQUFDeEMsQ0FBQSIsIm5hbWVzIjpbXSwic291cmNlcyI6WyJUeXBld3JpdGVyLnN2ZWx0ZSJdfQ== */");
}
function create_else_block(ctx) {
  let await_block_anchor;
  let promise;
  let current;
  let info = {
    ctx,
    current: null,
    token: null,
    hasCatch: false,
    pending: create_pending_block,
    then: create_then_block,
    catch: create_catch_block_1,
    blocks: [, , ,]
  };
  handle_promise(promise = ctx[6](), info);
  const block = {
    c: function create() {
      await_block_anchor = empty();
      info.block.c();
    },
    l: function claim(nodes) {
      await_block_anchor = empty();
      info.block.l(nodes);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, await_block_anchor, anchor);
      info.block.m(target, info.anchor = anchor);
      info.mount = () => await_block_anchor.parentNode;
      info.anchor = await_block_anchor;
      current = true;
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      info.ctx = ctx;
      if (dirty & 64 && promise !== (promise = ctx[6]()) && handle_promise(promise, info)) {
      } else {
        update_await_block_branch(info, ctx, dirty);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(info.block);
      current = true;
    },
    o: function outro(local) {
      for (let i = 0; i < 3; i += 1) {
        const block2 = info.blocks[i];
        transition_out(block2);
      }
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(await_block_anchor);
      info.block.d(detaching);
      info.token = null;
      info = null;
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block.name,
    type: "else",
    source: "(103:4) {:else}",
    ctx
  });
  return block;
}
function create_if_block(ctx) {
  let div;
  let current;
  const default_slot_template = ctx[24].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[23], null);
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      if (default_slot)
        default_slot.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", "typewriter-container svelte-1gv2i7t");
      add_location(div, file, 99, 8, 3230);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 8388608)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            ctx2[23],
            !current ? get_all_dirty_from_scope(ctx2[23]) : get_slot_changes(default_slot_template, ctx2[23], dirty, null),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block.name,
    type: "if",
    source: "(99:4) {#if disabled}",
    ctx
  });
  return block;
}
function create_catch_block_1(ctx) {
  const block = {
    c: noop,
    l: noop,
    m: noop,
    p: noop,
    i: noop,
    o: noop,
    d: noop
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_catch_block_1.name,
    type: "catch",
    source: `(1:0) <script>     export let mode = \\"concurrent\\"      // general-purpose props  export let interval = 30  export let cursor = true     export let keepCursorOnFinish = false  export let delay = 0     export let showCursorOnDelay = false     export let disabled = false     export let element = \\"div\\"      // mode-specific props     export let scrambleDuration = 3000     export let scrambleSlowdown = true  export let unwriteInterval = 30     export let wordInterval = 1500      $: isLoopMode = /^loop(Once|Random)?$/.test(mode)      // these modes stop once all given elements have finished their animations     // and support the cursor     $: isFiniteCursorMode = [\\"concurrent\\", \\"cascade\\", \\"loopOnce\\"].includes(mode)      $: invalidCursorOnFinish = !isFiniteCursorMode && keepCursorOnFinish     $: invalidCursorOnDelay = delay < 1 && showCursorOnDelay     $: invalidLoopProps = !isLoopMode && ($$props.unwriteInterval || $$props.wordInterval)     $: invalidScrambleProps = mode !== \\"scramble\\" && ($$props.scrambleDuration || $$props.scrambleSlowdown)     $: unnecessaryCursorOnFinish = typeof keepCursorOnFinish === 'number' && keepCursorOnFinish < 1      const modes = {         concurrent: () => import(\\"./modes/concurrent\\"),         cascade: () => import(\\"./modes/cascade\\"),         loop: () => import(\\"./modes/loop\\"),         loopOnce: () => import(\\"./modes/loopOnce\\"),         loopRandom: () => import(\\"./modes/loopRandom\\"),         scramble: () => import(\\"./modes/scramble\\")     }`,
    ctx
  });
  return block;
}
function create_then_block(ctx) {
  let await_block_anchor;
  let promise;
  let current;
  let info = {
    ctx,
    current: null,
    token: null,
    hasCatch: false,
    pending: create_pending_block_1,
    then: create_then_block_1,
    catch: create_catch_block,
    value: 25,
    blocks: [, , ,]
  };
  handle_promise(promise = ctx[7][ctx[0]](), info);
  const block = {
    c: function create() {
      await_block_anchor = empty();
      info.block.c();
    },
    l: function claim(nodes) {
      await_block_anchor = empty();
      info.block.l(nodes);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, await_block_anchor, anchor);
      info.block.m(target, info.anchor = anchor);
      info.mount = () => await_block_anchor.parentNode;
      info.anchor = await_block_anchor;
      current = true;
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      info.ctx = ctx;
      if (dirty & 1 && promise !== (promise = ctx[7][ctx[0]]()) && handle_promise(promise, info)) {
      } else {
        update_await_block_branch(info, ctx, dirty);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(info.block);
      current = true;
    },
    o: function outro(local) {
      for (let i = 0; i < 3; i += 1) {
        const block2 = info.blocks[i];
        transition_out(block2);
      }
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(await_block_anchor);
      info.block.d(detaching);
      info.token = null;
      info = null;
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_then_block.name,
    type: "then",
    source: "(110:8) {:then}",
    ctx
  });
  return block;
}
function create_catch_block(ctx) {
  const block = {
    c: noop,
    l: noop,
    m: noop,
    p: noop,
    i: noop,
    o: noop,
    d: noop
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_catch_block.name,
    type: "catch",
    source: `(1:0) <script>     export let mode = \\"concurrent\\"      // general-purpose props  export let interval = 30  export let cursor = true     export let keepCursorOnFinish = false  export let delay = 0     export let showCursorOnDelay = false     export let disabled = false     export let element = \\"div\\"      // mode-specific props     export let scrambleDuration = 3000     export let scrambleSlowdown = true  export let unwriteInterval = 30     export let wordInterval = 1500      $: isLoopMode = /^loop(Once|Random)?$/.test(mode)      // these modes stop once all given elements have finished their animations     // and support the cursor     $: isFiniteCursorMode = [\\"concurrent\\", \\"cascade\\", \\"loopOnce\\"].includes(mode)      $: invalidCursorOnFinish = !isFiniteCursorMode && keepCursorOnFinish     $: invalidCursorOnDelay = delay < 1 && showCursorOnDelay     $: invalidLoopProps = !isLoopMode && ($$props.unwriteInterval || $$props.wordInterval)     $: invalidScrambleProps = mode !== \\"scramble\\" && ($$props.scrambleDuration || $$props.scrambleSlowdown)     $: unnecessaryCursorOnFinish = typeof keepCursorOnFinish === 'number' && keepCursorOnFinish < 1      const modes = {         concurrent: () => import(\\"./modes/concurrent\\"),         cascade: () => import(\\"./modes/cascade\\"),         loop: () => import(\\"./modes/loop\\"),         loopOnce: () => import(\\"./modes/loopOnce\\"),         loopRandom: () => import(\\"./modes/loopRandom\\"),         scramble: () => import(\\"./modes/scramble\\")     }`,
    ctx
  });
  return block;
}
function create_then_block_1(ctx) {
  let previous_tag = ctx[4];
  let svelte_element_anchor;
  let current;
  validate_dynamic_element(ctx[4]);
  validate_void_dynamic_element(ctx[4]);
  let svelte_element = ctx[4] && create_dynamic_element(ctx);
  const block = {
    c: function create() {
      if (svelte_element)
        svelte_element.c();
      svelte_element_anchor = empty();
    },
    l: function claim(nodes) {
      if (svelte_element)
        svelte_element.l(nodes);
      svelte_element_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (svelte_element)
        svelte_element.m(target, anchor);
      insert_hydration_dev(target, svelte_element_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (ctx2[4]) {
        if (!previous_tag) {
          svelte_element = create_dynamic_element(ctx2);
          svelte_element.c();
          svelte_element.m(svelte_element_anchor.parentNode, svelte_element_anchor);
        } else if (safe_not_equal(previous_tag, ctx2[4])) {
          svelte_element.d(1);
          validate_dynamic_element(ctx2[4]);
          validate_void_dynamic_element(ctx2[4]);
          svelte_element = create_dynamic_element(ctx2);
          svelte_element.c();
          svelte_element.m(svelte_element_anchor.parentNode, svelte_element_anchor);
        } else {
          svelte_element.p(ctx2, dirty);
        }
      } else if (previous_tag) {
        svelte_element.d(1);
        svelte_element = null;
      }
      previous_tag = ctx2[4];
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(svelte_element);
      current = true;
    },
    o: function outro(local) {
      transition_out(svelte_element);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(svelte_element_anchor);
      if (svelte_element)
        svelte_element.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_then_block_1.name,
    type: "then",
    source: "(111:52)                  <svelte:element this={element}",
    ctx
  });
  return block;
}
function create_dynamic_element(ctx) {
  let svelte_element;
  let selectedMode_default_action;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = ctx[24].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[23], null);
  let svelte_element_levels = [
    {
      class: "typewriter-container svelte-1gv2i7t"
    }
  ];
  let svelte_element_data = {};
  for (let i = 0; i < svelte_element_levels.length; i += 1) {
    svelte_element_data = assign(svelte_element_data, svelte_element_levels[i]);
  }
  const block = {
    c: function create() {
      svelte_element = element(ctx[4]);
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      svelte_element = claim_element(nodes, (ctx[4] || "null").toUpperCase(), { class: true });
      var svelte_element_nodes = children(svelte_element);
      if (default_slot)
        default_slot.l(svelte_element_nodes);
      svelte_element_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      if (/-/.test(ctx[4])) {
        set_custom_element_data_map(svelte_element, svelte_element_data);
      } else {
        set_attributes(svelte_element, svelte_element_data);
      }
      toggle_class(svelte_element, "cursor", ctx[1]);
      add_location(svelte_element, file, 111, 16, 3608);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svelte_element, anchor);
      if (default_slot) {
        default_slot.m(svelte_element, null);
      }
      current = true;
      if (!mounted) {
        dispose = action_destroyer(selectedMode_default_action = ctx[25].default(svelte_element, ctx[5]));
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 8388608)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            ctx2[23],
            !current ? get_all_dirty_from_scope(ctx2[23]) : get_slot_changes(default_slot_template, ctx2[23], dirty, null),
            null
          );
        }
      }
      svelte_element_data = get_spread_update(svelte_element_levels, [
        {
          class: "typewriter-container svelte-1gv2i7t"
        }
      ]);
      if (/-/.test(ctx2[4])) {
        set_custom_element_data_map(svelte_element, svelte_element_data);
      } else {
        set_attributes(svelte_element, svelte_element_data);
      }
      if (selectedMode_default_action && is_function(selectedMode_default_action.update) && dirty & 32)
        selectedMode_default_action.update.call(null, ctx2[5]);
      toggle_class(svelte_element, "cursor", ctx2[1]);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(svelte_element);
      if (default_slot)
        default_slot.d(detaching);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_dynamic_element.name,
    type: "child_dynamic_element",
    source: '(112:16) <svelte:element this={element} use:selectedMode.default={props} class:cursor class=\\"typewriter-container\\">',
    ctx
  });
  return block;
}
function create_pending_block_1(ctx) {
  const block = {
    c: noop,
    l: noop,
    m: noop,
    p: noop,
    i: noop,
    o: noop,
    d: noop
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_pending_block_1.name,
    type: "pending",
    source: `(1:0) <script>     export let mode = \\"concurrent\\"      // general-purpose props  export let interval = 30  export let cursor = true     export let keepCursorOnFinish = false  export let delay = 0     export let showCursorOnDelay = false     export let disabled = false     export let element = \\"div\\"      // mode-specific props     export let scrambleDuration = 3000     export let scrambleSlowdown = true  export let unwriteInterval = 30     export let wordInterval = 1500      $: isLoopMode = /^loop(Once|Random)?$/.test(mode)      // these modes stop once all given elements have finished their animations     // and support the cursor     $: isFiniteCursorMode = [\\"concurrent\\", \\"cascade\\", \\"loopOnce\\"].includes(mode)      $: invalidCursorOnFinish = !isFiniteCursorMode && keepCursorOnFinish     $: invalidCursorOnDelay = delay < 1 && showCursorOnDelay     $: invalidLoopProps = !isLoopMode && ($$props.unwriteInterval || $$props.wordInterval)     $: invalidScrambleProps = mode !== \\"scramble\\" && ($$props.scrambleDuration || $$props.scrambleSlowdown)     $: unnecessaryCursorOnFinish = typeof keepCursorOnFinish === 'number' && keepCursorOnFinish < 1      const modes = {         concurrent: () => import(\\"./modes/concurrent\\"),         cascade: () => import(\\"./modes/cascade\\"),         loop: () => import(\\"./modes/loop\\"),         loopOnce: () => import(\\"./modes/loopOnce\\"),         loopRandom: () => import(\\"./modes/loopRandom\\"),         scramble: () => import(\\"./modes/scramble\\")     }`,
    ctx
  });
  return block;
}
function create_pending_block(ctx) {
  let if_block_anchor;
  let if_block = ctx[2] && create_if_block_1(ctx);
  const block = {
    c: function create() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if (if_block)
        if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
    },
    p: function update(ctx2, dirty) {
      if (ctx2[2]) {
        if (if_block) {
        } else {
          if_block = create_if_block_1(ctx2);
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach_dev(if_block_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_pending_block.name,
    type: "pending",
    source: "(104:31)              {#if showCursorOnDelay}",
    ctx
  });
  return block;
}
function create_if_block_1(ctx) {
  let div;
  let p;
  const block = {
    c: function create() {
      div = element("div");
      p = element("p");
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      p = claim_element(div_nodes, "P", { class: true });
      children(p).forEach(detach_dev);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(p, "class", "typing");
      add_location(p, file, 106, 20, 3459);
      attr_dev(div, "class", "typewriter-container cursor svelte-1gv2i7t");
      add_location(div, file, 105, 16, 3397);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      append_hydration_dev(div, p);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_1.name,
    type: "if",
    source: "(105:12) {#if showCursorOnDelay}",
    ctx
  });
  return block;
}
function create_key_block(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block, create_else_block];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (ctx2[3])
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const block = {
    c: function create() {
      if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if_blocks[current_block_type_index].d(detaching);
      if (detaching)
        detach_dev(if_block_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_key_block.name,
    type: "key",
    source: "(98:0) {#key $$props}",
    ctx
  });
  return block;
}
function create_fragment(ctx) {
  let t;
  let previous_key = ctx[8];
  let key_block_anchor;
  let current;
  let key_block = create_key_block(ctx);
  const block = {
    c: function create() {
      t = space();
      key_block.c();
      key_block_anchor = empty();
    },
    l: function claim(nodes) {
      t = claim_space(nodes);
      key_block.l(nodes);
      key_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, t, anchor);
      key_block.m(target, anchor);
      insert_hydration_dev(target, key_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & 256 && safe_not_equal(previous_key, previous_key = ctx2[8])) {
        group_outros();
        transition_out(key_block, 1, 1, noop);
        check_outros();
        key_block = create_key_block(ctx2);
        key_block.c();
        transition_in(key_block, 1);
        key_block.m(key_block_anchor.parentNode, key_block_anchor);
      } else {
        key_block.p(ctx2, dirty);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(key_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(key_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(t);
      if (detaching)
        detach_dev(key_block_anchor);
      key_block.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance($$self, $$props, $$invalidate) {
  let isLoopMode;
  let isFiniteCursorMode;
  let invalidCursorOnFinish;
  let invalidCursorOnDelay;
  let invalidLoopProps;
  let invalidScrambleProps;
  let unnecessaryCursorOnFinish;
  let delayPromise;
  let props;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Typewriter", slots, ["default"]);
  let { mode = "concurrent" } = $$props;
  let { interval = 30 } = $$props;
  let { cursor = true } = $$props;
  let { keepCursorOnFinish = false } = $$props;
  let { delay = 0 } = $$props;
  let { showCursorOnDelay = false } = $$props;
  let { disabled = false } = $$props;
  let { element: element2 = "div" } = $$props;
  let { scrambleDuration = 3e3 } = $$props;
  let { scrambleSlowdown = true } = $$props;
  let { unwriteInterval = 30 } = $$props;
  let { wordInterval = 1500 } = $$props;
  const modes = {
    concurrent: () => import("./concurrent-BDJL2KGI.js"),
    cascade: () => import("./cascade-B4ZSZQGD.js"),
    loop: () => import("./loop-2NB6VVML.js"),
    loopOnce: () => import("./loopOnce-2WO4AFUK.js"),
    loopRandom: () => import("./loopRandom-BBA4UBA6.js"),
    scramble: () => import("./scramble-7NQCXUX2.js")
  };
  $$self.$$set = ($$new_props) => {
    $$invalidate(8, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    if ("mode" in $$new_props)
      $$invalidate(0, mode = $$new_props.mode);
    if ("interval" in $$new_props)
      $$invalidate(9, interval = $$new_props.interval);
    if ("cursor" in $$new_props)
      $$invalidate(1, cursor = $$new_props.cursor);
    if ("keepCursorOnFinish" in $$new_props)
      $$invalidate(10, keepCursorOnFinish = $$new_props.keepCursorOnFinish);
    if ("delay" in $$new_props)
      $$invalidate(11, delay = $$new_props.delay);
    if ("showCursorOnDelay" in $$new_props)
      $$invalidate(2, showCursorOnDelay = $$new_props.showCursorOnDelay);
    if ("disabled" in $$new_props)
      $$invalidate(3, disabled = $$new_props.disabled);
    if ("element" in $$new_props)
      $$invalidate(4, element2 = $$new_props.element);
    if ("scrambleDuration" in $$new_props)
      $$invalidate(12, scrambleDuration = $$new_props.scrambleDuration);
    if ("scrambleSlowdown" in $$new_props)
      $$invalidate(13, scrambleSlowdown = $$new_props.scrambleSlowdown);
    if ("unwriteInterval" in $$new_props)
      $$invalidate(14, unwriteInterval = $$new_props.unwriteInterval);
    if ("wordInterval" in $$new_props)
      $$invalidate(15, wordInterval = $$new_props.wordInterval);
    if ("$$scope" in $$new_props)
      $$invalidate(23, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    mode,
    interval,
    cursor,
    keepCursorOnFinish,
    delay,
    showCursorOnDelay,
    disabled,
    element: element2,
    scrambleDuration,
    scrambleSlowdown,
    unwriteInterval,
    wordInterval,
    modes,
    props,
    delayPromise,
    unnecessaryCursorOnFinish,
    invalidScrambleProps,
    invalidLoopProps,
    invalidCursorOnDelay,
    invalidCursorOnFinish,
    isLoopMode,
    isFiniteCursorMode
  });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(8, $$props = assign(assign({}, $$props), $$new_props));
    if ("mode" in $$props)
      $$invalidate(0, mode = $$new_props.mode);
    if ("interval" in $$props)
      $$invalidate(9, interval = $$new_props.interval);
    if ("cursor" in $$props)
      $$invalidate(1, cursor = $$new_props.cursor);
    if ("keepCursorOnFinish" in $$props)
      $$invalidate(10, keepCursorOnFinish = $$new_props.keepCursorOnFinish);
    if ("delay" in $$props)
      $$invalidate(11, delay = $$new_props.delay);
    if ("showCursorOnDelay" in $$props)
      $$invalidate(2, showCursorOnDelay = $$new_props.showCursorOnDelay);
    if ("disabled" in $$props)
      $$invalidate(3, disabled = $$new_props.disabled);
    if ("element" in $$props)
      $$invalidate(4, element2 = $$new_props.element);
    if ("scrambleDuration" in $$props)
      $$invalidate(12, scrambleDuration = $$new_props.scrambleDuration);
    if ("scrambleSlowdown" in $$props)
      $$invalidate(13, scrambleSlowdown = $$new_props.scrambleSlowdown);
    if ("unwriteInterval" in $$props)
      $$invalidate(14, unwriteInterval = $$new_props.unwriteInterval);
    if ("wordInterval" in $$props)
      $$invalidate(15, wordInterval = $$new_props.wordInterval);
    if ("props" in $$props)
      $$invalidate(5, props = $$new_props.props);
    if ("delayPromise" in $$props)
      $$invalidate(6, delayPromise = $$new_props.delayPromise);
    if ("unnecessaryCursorOnFinish" in $$props)
      $$invalidate(16, unnecessaryCursorOnFinish = $$new_props.unnecessaryCursorOnFinish);
    if ("invalidScrambleProps" in $$props)
      $$invalidate(17, invalidScrambleProps = $$new_props.invalidScrambleProps);
    if ("invalidLoopProps" in $$props)
      $$invalidate(18, invalidLoopProps = $$new_props.invalidLoopProps);
    if ("invalidCursorOnDelay" in $$props)
      $$invalidate(19, invalidCursorOnDelay = $$new_props.invalidCursorOnDelay);
    if ("invalidCursorOnFinish" in $$props)
      $$invalidate(20, invalidCursorOnFinish = $$new_props.invalidCursorOnFinish);
    if ("isLoopMode" in $$props)
      $$invalidate(21, isLoopMode = $$new_props.isLoopMode);
    if ("isFiniteCursorMode" in $$props)
      $$invalidate(22, isFiniteCursorMode = $$new_props.isFiniteCursorMode);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 1) {
      $:
        $$invalidate(21, isLoopMode = /^loop(Once|Random)?$/.test(mode));
    }
    if ($$self.$$.dirty & 1) {
      $:
        $$invalidate(22, isFiniteCursorMode = ["concurrent", "cascade", "loopOnce"].includes(mode));
    }
    if ($$self.$$.dirty & 4195328) {
      $:
        $$invalidate(20, invalidCursorOnFinish = !isFiniteCursorMode && keepCursorOnFinish);
    }
    if ($$self.$$.dirty & 2052) {
      $:
        $$invalidate(19, invalidCursorOnDelay = delay < 1 && showCursorOnDelay);
    }
    $:
      $$invalidate(18, invalidLoopProps = !isLoopMode && ($$props.unwriteInterval || $$props.wordInterval));
    $:
      $$invalidate(17, invalidScrambleProps = mode !== "scramble" && ($$props.scrambleDuration || $$props.scrambleSlowdown));
    if ($$self.$$.dirty & 1024) {
      $:
        $$invalidate(16, unnecessaryCursorOnFinish = typeof keepCursorOnFinish === "number" && keepCursorOnFinish < 1);
    }
    if ($$self.$$.dirty & 1048576) {
      $:
        invalidCursorOnFinish && console.warn("[svelte-typewriter] The prop 'keepCursorOnFinish' is compatible only with finite modes");
    }
    if ($$self.$$.dirty & 524288) {
      $:
        invalidCursorOnDelay && console.warn("[svelte-typewriter] The prop 'showCursorOnDelay' has no effect if the delay is 0");
    }
    if ($$self.$$.dirty & 262144) {
      $:
        invalidLoopProps && console.warn("[svelte-typewriter] The props 'unwriteInterval' and 'wordInterval' are only compatible with loop modes");
    }
    if ($$self.$$.dirty & 131072) {
      $:
        invalidScrambleProps && console.warn("[svelte-typewriter] The props 'scrambleDuration' and 'scrambleSlowdown' are only compatible with scramble mode");
    }
    if ($$self.$$.dirty & 65536) {
      $:
        unnecessaryCursorOnFinish && console.warn("[svelte-typewriter] The prop 'keepCursorOnFinish' has no effect with values lower than 1");
    }
    if ($$self.$$.dirty & 2048) {
      $:
        $$invalidate(6, delayPromise = () => new Promise((resolve) => setTimeout(() => resolve(delay), delay)));
    }
    if ($$self.$$.dirty & 65054) {
      $:
        $$invalidate(5, props = {
          interval,
          cursor,
          keepCursorOnFinish,
          delay,
          showCursorOnDelay,
          disabled,
          element: element2,
          scrambleDuration,
          scrambleSlowdown,
          unwriteInterval,
          wordInterval
        });
    }
  };
  $$props = exclude_internal_props($$props);
  return [
    mode,
    cursor,
    showCursorOnDelay,
    disabled,
    element2,
    props,
    delayPromise,
    modes,
    $$props,
    interval,
    keepCursorOnFinish,
    delay,
    scrambleDuration,
    scrambleSlowdown,
    unwriteInterval,
    wordInterval,
    unnecessaryCursorOnFinish,
    invalidScrambleProps,
    invalidLoopProps,
    invalidCursorOnDelay,
    invalidCursorOnFinish,
    isLoopMode,
    isFiniteCursorMode,
    $$scope,
    slots
  ];
}
var Typewriter = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance,
      create_fragment,
      safe_not_equal,
      {
        mode: 0,
        interval: 9,
        cursor: 1,
        keepCursorOnFinish: 10,
        delay: 11,
        showCursorOnDelay: 2,
        disabled: 3,
        element: 4,
        scrambleDuration: 12,
        scrambleSlowdown: 13,
        unwriteInterval: 14,
        wordInterval: 15
      },
      add_css
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Typewriter",
      options,
      id: create_fragment.name
    });
  }
  get mode() {
    throw new Error("<Typewriter>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set mode(value) {
    throw new Error("<Typewriter>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get interval() {
    throw new Error("<Typewriter>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set interval(value) {
    throw new Error("<Typewriter>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get cursor() {
    throw new Error("<Typewriter>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set cursor(value) {
    throw new Error("<Typewriter>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get keepCursorOnFinish() {
    throw new Error("<Typewriter>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set keepCursorOnFinish(value) {
    throw new Error("<Typewriter>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get delay() {
    throw new Error("<Typewriter>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set delay(value) {
    throw new Error("<Typewriter>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get showCursorOnDelay() {
    throw new Error("<Typewriter>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set showCursorOnDelay(value) {
    throw new Error("<Typewriter>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get disabled() {
    throw new Error("<Typewriter>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set disabled(value) {
    throw new Error("<Typewriter>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get element() {
    throw new Error("<Typewriter>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set element(value) {
    throw new Error("<Typewriter>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get scrambleDuration() {
    throw new Error("<Typewriter>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set scrambleDuration(value) {
    throw new Error("<Typewriter>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get scrambleSlowdown() {
    throw new Error("<Typewriter>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set scrambleSlowdown(value) {
    throw new Error("<Typewriter>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get unwriteInterval() {
    throw new Error("<Typewriter>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set unwriteInterval(value) {
    throw new Error("<Typewriter>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get wordInterval() {
    throw new Error("<Typewriter>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set wordInterval(value) {
    throw new Error("<Typewriter>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Typewriter_default = Typewriter;
export {
  cascade_default as cascade,
  concurrent_default as concurrent,
  Typewriter_default as default,
  loop_default as loop,
  loopOnce_default as loopOnce,
  loopRandom_default as loopRandom,
  scramble_default as scramble
};
//# sourceMappingURL=svelte-typewriter.js.map
