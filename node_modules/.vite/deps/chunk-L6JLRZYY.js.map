{
  "version": 3,
  "sources": ["../../svelte-typewriter/helpers/getLongestTextElement.js", "../../svelte-typewriter/helpers/onAnimationEnd.js", "../../svelte-typewriter/modes/concurrent.js"],
  "sourcesContent": ["/** @type {import(types').DescendingSortFunction} */\nconst descendingSortFunction = (firstElement, secondElement) =>\n\tsecondElement.text.length - firstElement.text.length\n\n/** @type {import(types').GetLongestTextElement} */\nconst getLongestTextElement = elements => {\n\tconst descendingTextLengthOrder = elements.sort(descendingSortFunction)\n\tconst longestTextElement = descendingTextLengthOrder[0].currentNode\n\treturn longestTextElement\n}\n\nexport { getLongestTextElement }\n", "/** @type {import(types').OnAnimationEnd} */\nconst onAnimationEnd = (element, callback) => {\n\tconst observer = new MutationObserver(mutations => {\n\t\tmutations.forEach(mutation => {\n\t\t\tconst elementAttributeChanged = mutation.type === 'attributes'\n\t\t\tconst elementFinishedTyping = mutation.target.classList.contains('finished-typing')\n\t\t\tif (elementAttributeChanged && elementFinishedTyping) callback()\n\t\t})\n\t})\n\n\tobserver.observe(element, {\n\t\tattributes: true,\n\t\tchildList: true,\n\t\tsubtree: true\n\t})\n}\n\nexport { onAnimationEnd }\n", "import { getLongestTextElement } from '../helpers/getLongestTextElement'\nimport { writeEffect } from '../helpers/writeEffect'\nimport { onAnimationEnd } from '../helpers/onAnimationEnd'\nimport { animationSetup } from '../helpers/animationSetup'\n\n// the name \"default\" cannot be used due to being a js keyword\nconst concurrent = (node, props) => {\n\tconst { options, elements } = animationSetup(node, props)\n\n\tconst lastElementToFinish = getLongestTextElement(elements)\n\tonAnimationEnd(lastElementToFinish, () => options.dispatch('done'))\n\n\tfor (const element of elements) {\n\t\t// \"then\" is required here to prevent blocking execution, thus keeping\n\t\t// the animation asynchronous\n\t\twriteEffect(element, options).then(() => {\n\t\t\tif (options.keepCursorOnFinish) {\n\t\t\t\tconst isNotLongestElement = element.currentNode !== lastElementToFinish\n\t\t\t\tisNotLongestElement &&\n\t\t\t\t\telement.currentNode.classList.replace('typing', 'finished-typing')\n\t\t\t} else {\n\t\t\t\telement.currentNode.classList.replace('typing', 'finished-typing')\n\t\t\t}\n\n\t\t\tconst cursorHasTimeout = typeof options.keepCursorOnFinish === 'number'\n\t\t\tcursorHasTimeout &&\n\t\t\t\tsetTimeout(() => {\n\t\t\t\t\telement.currentNode.classList.replace('typing', 'finished-typing')\n\t\t\t\t}, options.keepCursorOnFinish)\n\t\t})\n\t}\n}\n\nexport default concurrent\n"],
  "mappings": ";;;;;;;;AACA,IAAM,yBAAyB,CAAC,cAAc,kBAC7C,cAAc,KAAK,SAAS,aAAa,KAAK;AAG/C,IAAM,wBAAwB,cAAY;AACzC,QAAM,4BAA4B,SAAS,KAAK,sBAAsB;AACtE,QAAM,qBAAqB,0BAA0B,GAAG;AACxD,SAAO;AACR;;;ACRA,IAAM,iBAAiB,CAAC,SAAS,aAAa;AAC7C,QAAM,WAAW,IAAI,iBAAiB,eAAa;AAClD,cAAU,QAAQ,cAAY;AAC7B,YAAM,0BAA0B,SAAS,SAAS;AAClD,YAAM,wBAAwB,SAAS,OAAO,UAAU,SAAS,iBAAiB;AAClF,UAAI,2BAA2B;AAAuB,iBAAS;AAAA,IAChE,CAAC;AAAA,EACF,CAAC;AAED,WAAS,QAAQ,SAAS;AAAA,IACzB,YAAY;AAAA,IACZ,WAAW;AAAA,IACX,SAAS;AAAA,EACV,CAAC;AACF;;;ACTA,IAAM,aAAa,CAAC,MAAM,UAAU;AACnC,QAAM,EAAE,SAAS,SAAS,IAAI,eAAe,MAAM,KAAK;AAExD,QAAM,sBAAsB,sBAAsB,QAAQ;AAC1D,iBAAe,qBAAqB,MAAM,QAAQ,SAAS,MAAM,CAAC;AAElE,aAAW,WAAW,UAAU;AAG/B,gBAAY,SAAS,OAAO,EAAE,KAAK,MAAM;AACxC,UAAI,QAAQ,oBAAoB;AAC/B,cAAM,sBAAsB,QAAQ,gBAAgB;AACpD,+BACC,QAAQ,YAAY,UAAU,QAAQ,UAAU,iBAAiB;AAAA,MACnE,OAAO;AACN,gBAAQ,YAAY,UAAU,QAAQ,UAAU,iBAAiB;AAAA,MAClE;AAEA,YAAM,mBAAmB,OAAO,QAAQ,uBAAuB;AAC/D,0BACC,WAAW,MAAM;AAChB,gBAAQ,YAAY,UAAU,QAAQ,UAAU,iBAAiB;AAAA,MAClE,GAAG,QAAQ,kBAAkB;AAAA,IAC/B,CAAC;AAAA,EACF;AACD;AAEA,IAAO,qBAAQ;",
  "names": []
}
